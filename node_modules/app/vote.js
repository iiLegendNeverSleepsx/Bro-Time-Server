var { GuildChannel, RichEmbed } = require("discord.js");
var running = [];

function getScope(channel) {
	return channel instanceof GuildChannel ? channel.guild.id : channel.id;
}

function replaceTags(content, values) {
	var result = content;
	if (content instanceof RichEmbed) {
		result.setTitle(replaceTags(content.title, values));
		result.setDescription(replaceTags(content.description, values));
		result.setFooter(replaceTags(content.footer, values));
	} else {
		values.forEach((value) => {
			result = result.replace(value.tag, value.value);
		});
	}
	return result;
}

module.exports = function vote(time, channel, required,
	filter = () => { return true; },
	id = null,
	content = "A vote is required (<current>/<required>)!") {
	// If running contains [guild.id, channel.id], return rejected promise.
	var result;
	if (id != null && running.some((other) => getScope(channel) == other.scope && other.id === id)) {
		result = Promise.reject(new Error(`The vote for ${id} is still running.`));
	} else {
		if (id != null)
			running.push({scope: getScope(channel), id: id});

		result = new Promise((resolve, reject) => {
			try {
				channel.send(replaceTags(content, [{tag: "current", value: 0}, {tag: "required", value: required}])).then((message) => {
					Promise.all([message.react(":thumbsup:"), message.react(":thumbsdown:")]).then((reactions) => {
						var getTally = () => {
							var tally = 0;
							message.reactions.forEach((reaction) => {
								tally += reaction === reactions[0] ? reaction.users.size : -reaction.users.size;
							});
							return tally;
						};
						var updateMessage = (reaction) => {
							if (reaction.message.id === message.id)
								message.edit(replaceTags(content, [{tag: "current", value: Math.max(getTally(), 0)}, {tag: "required", value: required}]));
						};
						
						channel.client.on("messageReactionAdd", updateMessage);
						channel.client.on("messageReactionRemove", updateMessage);
						channel.client.setTimeout(() => {
							channel.client.off("messageReactionAdd", updateMessage);
							channel.client.off("messageReactionRemove", updateMessage);
							if (getTally() > 0) {
								resolve(true, reactions[0].users);
							} else {
								resolve(false, reactions[1].users);
							}
						}, time);
					});
				});
			} catch(exc) {
				reject(exc);
			}
		});
	}
	return result;
}
